#!/usr/local/bin/perl -- -*-cperl-*-

=head1 NAME

thawsession - Dump a frozen session to stdout

=head1 AUTHOR

Greg Sabino Mullane <greg@endpoint.com>

Camp support and predicate matching added by David Christensen <david@endpoint.com>

=head1 USAGE

First argument (mandatory): enough of the session name to be unique

Second argument (optional): enough of the catalog name to be unique

Can also view the latest X sessions with "latest [catalog_name] X"

Can also view all sessions matching a particular predicate by
providing "matching '...perl code...'"; the current session is aliased to $session.
TODO: expand docs for predicates/predicate aliases.

=cut

use strict;
use warnings;
use Storable;
use Data::Dumper;
use File::Find;

# TODO: add proper option parsing to support output types, etc. i.e.,
# the ability to select what parts of the structure we want to
# view/dump, using a similar syntax to the predicate parsing.
# also support turning off the '.' -> '->{}' handling.

$Data::Dumper::Terse=1;
$Data::Dumper::Quotekeys=0;
$Data::Dumper::Indent=1;

my $session = shift or die qq{Usage: $0 session_name [catalog_name]\n\n};
my $catalog = $ARGV[0] || '';      # to provide proper behavior when compiling a predicate

my %opts = ( debug => 1, hash_subst => 1 );

my ($camp) = $ENV{PWD} =~ /camp(\d+)/;

my $BASEDIR;

if (defined $camp) {
    $BASEDIR = "$ENV{HOME}/camp$camp/catalogs";
}
else {
    ## We assume that catalogs are found off of $HOME/catalogs
    ## If this is not the case, adjust it here:

    $BASEDIR = "$ENV{HOME}/catalogs";
}

## If more than one catalog lives there, we prefer $USER
length $catalog or $catalog = $ENV{USER} || '';

## Figure out the base directory for the catalog(s):
if (!-d $BASEDIR) {
    warn qq{Directory "$BASEDIR" was not found\n};
    warn qq{You may want to adjust \$HOME or \$BASEDIR\n};
    exit;
}

my $CATDIR = '';
my $catdir = "$BASEDIR/$catalog";
length $catalog and -d $catdir and $CATDIR = $catdir;

if (! $CATDIR) {
    opendir(CD, $BASEDIR) or die qq{Could not opendir "$BASEDIR": $!\n};
    my @subdir = grep { -d "$BASEDIR/$_" and ! /^\./ } readdir CD;
    closedir(CD) or die qq{Could not closedir "$BASEDIR": $!\n};

    $#subdir < 0 and die qq{The directory "$BASEDIR" has no valid subdirectories\n};
    if ($#subdir < 1) {
        $CATDIR = "$BASEDIR/$subdir[0]";
    }
    else {
        if (length $catalog) {
            my @unique = grep { /$catalog/i } @subdir;
            $#unique == 0 and $CATDIR = "$BASEDIR/$unique[0]";
        }
        if (! $CATDIR) {
            warn "More than one catalog found. Please specify which one:\n";
            for (@subdir) {
                warn "-->$_\n";
            }
            exit;
        }
    }
}

## Now figure out where the sessions are held:
my $SESSIONDIR = '';
for my $sdir (qw(session var/session)) {
    -d "$CATDIR/$sdir" and $SESSIONDIR = "$CATDIR/$sdir" and last;
}
$SESSIONDIR or die qq{Could not find a session directory off of "$CATDIR"\n};

## Looking for the latest?
if ($session =~ /latest/i) {
    my $latest = shift || 0;
    if (!$latest and $catalog =~ /^\d+$/) {
        $latest = $catalog;
    }
    &latest_sessions($latest||5);
}

## Looking for matches on a predicate?
if ($session =~ /matching/i) {
    die qq{'matching' option requires a predicate.\n} unless @ARGV;

    my $filter_sub = compile_predicate( @ARGV );

    &sessions_matching_predicate($filter_sub);
    exit;
}

## Now try and find the frozen session

my $first = substr($session,0,1);
my $second = substr($session,1,1) or die "Session name must be at least 2 characters long\n";

my $NEWDIR = "$SESSIONDIR/$first/$second";

if (! -d $NEWDIR) {
    warn qq{Could not find the session directory "$NEWDIR"\n};
    &latest_sessions(10);
}

## Which file do we want?
opendir(D, $NEWDIR) or die qq{Could not opendir "$NEWDIR": $!\n};
my @match;
for my $f (readdir(D)) {
    next if $f !~ /^$first$second/ or $f =~ /\.lock$/;
    if ($f =~ /^$session/) {
        push @match, $f;
    }
}
closedir D or die qq{Could not closedir "$NEWDIR": $!\n};

if (@match > 1) {
    print "Multiple matches found:\n";
    for (sort @match) {
        print "  $_\n";
    }
    exit;
}

if (@match < 1) {
    warn "No matching sessions found\n";
    &latest_sessions(10);
}

$session = $match[0];
my $sfile = "$NEWDIR/$session";

my $mtime = localtime($^T-((-M $sfile)*60*60*24));
print "Session file: $sfile\nLast modified: $mtime\n";

my $hash = get_session_hash($sfile);

print Dumper $hash;
exit;

sub get_session_hash {
    my $sfile = shift;
    
    my $hash;
    eval {
        $hash = retrieve($sfile);
    };
    if ($@) {
        $@ =~ /Magic number/ and die qq{Not a storable file: "$sfile"\n};
        die qq{Could not thaw "$sfile": $@\n};
    }
    return $hash;
}

sub latest_sessions {
    my $count = shift || 5;

    our %sfile;
    finddepth({ wanted => sub {
                -f $File::Find::name
                and $File::Find::name !~ /\.lock/
                and $sfile{$File::Find::name} = -M $File::Find::name;
              },
              no_chdir => 1}, $SESSIONDIR);
    printf "Total session files found: %d\n", scalar keys %sfile;
    print "Newest $count:\n";
    for my $sfile (sort { $sfile{$a} <=> $sfile{$b} } keys %sfile) {
        last if ! $count--;
        my $mtime = localtime($^T - ($sfile{$sfile}*60*60*24));
        $sfile =~ s{.*/(.+)}{$1};
        print "  $sfile ($mtime)\n";
    }
    exit;

} ## end of latest_sessions

sub compile_predicate {
    my $predicate_fragment = join ' ', @_;
    
    # this regexp just takes a literal foo.bar and turns it into
    # a foo->{bar} construct; simplifies command-line queries with
    # less typing in the common case.
    if ($opts{hash_subst}) {
        $predicate_fragment =~ s/(?<![.])\.(\w+)/->{$1}/g;
    }

    my $predicate_template = sprintf <<'EOS', $predicate_fragment;
sub {
    no warnings;

    my $session = shift;
    local ($_)  = $session;

    # setup the predicate environment with aliased variables for the top-level hash keys.
    # based on the list of variable names on www.interchange.rtfm.info and common aliases.
    my $accesses    =         $_->{accesses};
    my $arg         = my $a = $_->{arg};
    my $browser     = my $b = $_->{browser};
    my $carts       =         $_->{carts};
    my $cart        = my $c = $_->{carts}->{main};
    my $items       = my $i = $_->{carts}->{main};
    my $host        = my $h = $_->{host};
    my $id          =         $_->{id};
    my $last_error  =         $_->{last_error};
    my $last_search =         $_->{last_search};
    my $last_url    =         $_->{last_url};
    my $logged_in   =         $_->{logged_in};
    my $ohost       =         $_->{ohost};
    my $referer     =         $_->{referer};
    my $scratch     = my $s = $_->{scratch};
    my $username    = my $u = $_->{username};

    # helpful syntactic equivalences so you don't^W^Wmay not have to escape the sigils
    sub accesses    { $accesses };
    sub arg         { $arg };
    sub browser     { $browser };
    sub carts       { $carts };
    sub cart        { $cart };
    sub items       { $items };
    sub host        { $host };
    sub id          { $id };
    sub last_error  { $last_error };
    sub last_search { $last_search };
    sub last_url    { $last_url };
    sub logged_in   { $logged_in };
    sub ohost       { $ohost };
    sub referer     { $referer };
    sub scratch     { $scratch };
    sub sc          { $scratch };
    sub username    { $username };

    return %s;
};
EOS
    my $predicate = eval $predicate_template; ## no critic

    if ($@) {
        warn qq{Couldn't compile predicate: $@\n};
        warn qq{\n$predicate_template\n} if $opts{dump_template};

        exit 1;
    }
    
    return $predicate;
}

sub sessions_matching_predicate {
    my $predicate = shift;

    die "Must provide a sub to sessions_matching_predicate()!\n" unless $predicate and ref $predicate eq 'CODE';

    my @sessions;
    finddepth({ wanted => sub {
                if (-f $File::Find::name and $File::Find::name !~ /\.lock/) {
                    #warn $File::Find::name;
                    
                    eval {
                        if (my $session = get_session_hash($File::Find::name)) {
                            if ($predicate->($session)) {
                                push @sessions, $File::Find::name;
                            }
                        }
                    };
                    # ignoring errors, because, frankly, there's no point in looking at them.
                }
              },
              no_chdir => 1}, $SESSIONDIR);

    if (@sessions) {
        print join "\n", @sessions;
        print "\n";
    }

    exit;
} ## end of sessions_matching_predicate
